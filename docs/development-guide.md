# 开发指南

## 环境搭建

### 本地开发环境

1. 安装 Go 1.19+
2. 安装 Docker 和 Docker Compose
3. 安装 PostgreSQL 客户端
4. 安装 Redis 客户端

### 启动依赖服务

使用 Docker Compose 启动数据库和缓存服务：

```bash
docker-compose up -d
```

### 配置环境变量

复制环境变量模板并配置：

```bash
cp .env.example .env
# 编辑 .env 文件
```

## 项目结构说明

### 目录结构

```
.
├── cmd/                  # 主程序入口
│   └── main.go          # 程序启动文件
├── internal/            # 内部包（私有代码）
│   ├── handlers/        # HTTP请求处理
│   ├── services/        # 业务逻辑
│   ├── models/          # 数据模型
│   └── middleware/      # 中间件
├── pkg/                 # 公共包（可被外部引用）
│   └── utils/           # 工具函数
├── tests/               # 测试文件
├── docs/                # 文档
├── .github/             # GitHub 配置
└── README.md            # 项目说明
```

### 代码组织原则

1. `cmd/` - 程序入口点，包含 main 函数
2. `internal/` - 私有应用代码，不允许外部导入
3. `pkg/` - 可被外部项目导入的公共代码
4. `tests/` - 测试文件

## 编码规范

### 包命名

- 包名应简洁、小写，不使用下划线
- 包名应与其所在目录名一致

### 函数命名

- 使用驼峰命名法
- 函数名应清晰表达其功能
- Getter 方法省略 Get 前缀

### 变量命名

- 使用驼峰命名法
- 局部变量可使用简短命名
- 导出变量使用描述性命名

### 错误处理

- 错误应被显式处理
- 使用自定义错误类型提供更多信息
- 记录错误日志便于调试

## 测试策略

### 单元测试

- 每个函数都应有相应的单元测试
- 使用 testify/assert 库简化断言
- 测试覆盖率应达到 80% 以上

### 集成测试

- 测试与数据库、缓存等外部服务的交互
- 使用测试容器模拟外部依赖
- 集成测试应独立于单元测试

### 性能测试

- 关键路径应有性能基准测试
- 使用 Go 内置的 benchmark 功能
- 定期运行性能测试监控性能变化

## API 设计

### RESTful 设计原则

- 使用标准 HTTP 方法
- 合理使用 HTTP 状态码
- URL 应简洁、有意义
- 支持版本控制

### 请求/响应格式

- 使用 JSON 格式
- 统一错误响应格式
- 支持分页和过滤

## 数据库设计

### 模型定义

- 使用 GORM 作为 ORM 库
- 模型应包含必要的索引
- 使用软删除避免数据丢失

### 迁移管理

- 使用 GORM 的自动迁移功能
- 复杂迁移使用独立的迁移脚本
- 迁移脚本应可回滚

## 日志记录

### 日志级别

- Debug: 调试信息
- Info: 一般信息
- Warn: 警告信息
- Error: 错误信息

### 日志格式

- 使用结构化日志
- 包含请求 ID 便于追踪
- 记录关键业务信息

## 部署流程

### 构建镜像

```bash
docker build -t game-server-ai .
```

### 运行容器

```bash
docker run -p 8080:8080 game-server-ai
```

### Kubernetes 部署

- 使用 Helm 管理部署配置
- 配置健康检查和就绪检查
- 设置资源限制和请求

## 监控和告警

### 指标收集

- 收集关键业务指标
- 收集系统性能指标
- 使用 Prometheus 格式暴露指标

### 日志收集

- 使用 Fluentd 收集日志
- 将日志发送到 Elasticsearch
- 使用 Kibana 进行日志分析

### 告警策略

- 设置关键指标的告警阈值
- 配置多级告警机制
- 告警应包含足够的上下文信息
